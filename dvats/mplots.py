# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/mplots.ipynb.

# %% auto 0
__all__ = ['mplot_path', 'eamonn_drive_mplots', 'euclidean_distance', 'z_normalize', 'z_normalized_euclidean_distance',
           'show_sequence', 'plot_with_dots', 'show_subsequence', 'plot_subsequence', 'GD_Mat', 'MatlabMatrix',
           'find_dominant_window_sizes_list', 'plot_subsequences_aux', 'plot_subsequences', 'plot_dataFrame',
           'plot_dataFrame_compareSubsequences', 'df_plot_colored_variables', 'plot_df_with_intervals_and_colors',
           'make_symmetric_', 'check_symmetric', 'moving_mean', 'sum_of_squared_differences', 'get_precomputes',
           'convert_non_finite_to_zero', 'distance_matrix', 'DistanceProfile', 'DistanceMatrix', 'plot_motif',
           'plot_motif_separated', 'MatrixProfile', 'matrix_profile', 'compute', 'MatrixProfiles', 'MatrixProfilePlot',
           'MatrixProfilePlotCached']

# %% ../nbs/mplots.ipynb 4
## -- Deepvats
import dvats.load as load
import dvats.memory as mem
import dvats.utils as ut

## -- Matrix profile
import pyscamp as scamp
import stumpy as stump 
## -- Utilities
import os
import numpy as np
import pandas as pd
import datetime as dt
import math
import warnings
#! pip install aeon | TODO: Ponerlo en el dockerfile
from aeon.segmentation._clasp import ClaSPSegmenter, find_dominant_window_sizes
from aeon.datasets import load_electric_devices_segmentation
from aeon.visualisation import plot_series_with_change_points, plot_series_with_profiles

## -- Classes & types
from dataclasses import dataclass, field
from typing import List, Optional, Tuple, Callable
## -- Plotting
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.dates as dates

from matplotlib.gridspec import GridSpec
from matplotlib.patches import Rectangle

from mpl_toolkits.axes_grid1 import ImageGrid

## -- Interactive Plots
import ipywidgets as widgets
from IPython.display import display, clear_output


from copy import deepcopy
plt.style.use('https://raw.githubusercontent.com/TDAmeritrade/stumpy/main/docs/stumpy.mplstyle')

from concurrent.futures import ThreadPoolExecutor



# %% ../nbs/mplots.ipynb 5
#-- "Importing" MPlots MATLAB code
from oct2py import octave
mplot_path = os.path.expanduser('~/work/nbs/mplot')
octave.addpath(mplot_path);
octave.chdir(mplot_path);
#%load_ext oct2py.ipython
octave.register_graphics_toolkit('fltk')
octave.graphics_toolkit('fltk')
octave.set(0, 'defaultfigurevisible', 'on');

# %% ../nbs/mplots.ipynb 10
def euclidean_distance (
    vector_a    : List [ float ],
    vector_b    : List [ float ],
    print_flag  : bool = False,
    time_flag   : bool = False
) -> Tuple[float, Optional[ ut.Time ]]:
    """
    Calculates the Euclidean distance between two vectors.

    Args:
        vector_a: First vector as a list of floats.
        vector_b: Second vector as a list of floats.
        print_flag: If True, prints the vectors.
        time_flag: If True, measures and displays the time taken by the function.

    Returns:
        A tuple containing the distance and an object of Time if time_flag is True, or None otherwise.
    """
    t = None 
    #if print_flag: print("--> Ensuring the vectors are numpy arrays")
    vector_a = np.array(vector_a)
    vector_b = np.array(vector_b)
    if print_flag: 
        print("va", vector_a)
        print("vb", vector_b)
    if time_flag:
        t = ut.Time(function = ut.funcname())
        t.start(print_flag = print_flag)
    dist = np.linalg.norm(vector_a - vector_b)
    if time_flag: 
        t.end(print_flag = print_flag)
        if print_flag: t.show()
    return dist, t

# %% ../nbs/mplots.ipynb 13
def z_normalize(
    sequence    : List [ float ],
    print_flag  : bool = False,
    time_flag   : bool = False
) -> Tuple[ List[ float ], Optional[ ut.Time ] ]:
    t = None
    if time_flag:
        t = ut.Time(function=ut.funcname())
        t.start(print_flag)
    
    mean    = np.mean(sequence)
    std     = np.std(sequence)
    res     = (sequence - mean) / std
    
    if time_flag: 
        t.end(print_flag)
        if print_flag: t.show()
    return res, t

# %% ../nbs/mplots.ipynb 15
def z_normalized_euclidean_distance(
    vector_a    : List [ float ],
    vector_b    : List [ float ],
    print_flag  : bool = False,
    time_flag   : bool = False,
    inside_times: bool = False
) -> Tuple[ List [ float ], Optional[ ut.Time ], Optional [ List [ ut.Time ] ] ]:
    t = None
    ts = [ None, None, None ]
    if print_flag: 
        print("va", vector_a)
        print("vb", vector_b)

    if time_flag:
        t = ut.Time( function = ut.funcname() )
        t.start(print_flag)
    
    #-- Normalize
    vector_a, ts[0] = z_normalize(vector_a, time_flag = inside_times)
    vector_b, ts[1] = z_normalize(vector_b, time_flag = inside_times)   

    #-- Compute distance
    res, ts[2] = euclidean_distance(vector_a, vector_b, time_flag = inside_times)
    
    if time_flag:
        t.end(print_flag)
        if print_flag: t.show()
    if print_flag: 
        print("zn-va", vector_a)
        print("zn-vb", vector_b)
        print("dist", res)
    return res, t, ts

# %% ../nbs/mplots.ipynb 18
def show_sequence(
    data         : List[ List [ float ] ] = None, 
    hide_rows    : bool = False, 
    hide_columns : bool = True
):
    """
    Show the sequence in a nice format similar to stumpy tutorials
    """
    df          = pd.DataFrame(data)
    styled_df   = df.style
    if hide_rows: 
        styled_df = styled_df.hide(axis='index')
    if hide_columns: 
        styled_df = styled_df.hide(axis='columns')
    styled_df = styled_df.set_table_styles([
        {'selector': '',
         'props': [('border', '2px solid black'),
                   ('text-align', 'center'),
                   ('font-family', 'Arial'),
                   ('border-collapse', 'collapse')]},
        {'selector': 'td',
         'props': [('border', '1px solid black'),
                   ('padding', '5px')]}
    ])
    display(styled_df)

# %% ../nbs/mplots.ipynb 19
def plot_with_dots(
    time_series             : List [ float ]    = None,
    xlabel                  : str               = 'Index (time)',
    ylabel                  : str               = 'Value',
    title                   : str               = 'Time series',
    sequence_flag           : bool              = True,
    show_sequence_before    : bool              = True, 
    hide_rows               : bool              = True,
    hide_columns            : bool              = False,
    show_title              : bool              = True   
  ) -> None:
    if sequence_flag and show_sequence_before: 
        show_sequence([time_series], hide_rows, hide_columns)
    n = len(time_series)
    x_coords = range(n)
    plt.plot(x_coords, time_series)
    plt.scatter(x_coords, time_series, color='red')
    if show_title: plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.show()
    if sequence_flag and not show_sequence_before: show_sequence([time_series], hide_rows, hide_columns)
    return None



# %% ../nbs/mplots.ipynb 22
def show_subsequence(
        data         : List [ float ], 
        i            : int  = 0, 
        m            : int  = 1, 
        hide_rows    : bool = False, 
        hide_columns : bool = True, 
    ):
        """ Show the subsequence in a nice format similar to stumpy tutorials"""
        show_sequence(
                data            = [data[i:m]],
                hide_rows       = hide_rows, 
                hide_columns    = hide_columns, 
        )

# %% ../nbs/mplots.ipynb 24
def plot_subsequence(
    TA              : List [ float ]    = None,
    sequence_i      : int               = 0,
    subsequence_len : int               = 1,
    color           : str               = 'green',
    dots            : bool              = True,
    dots_color      : str               = 'red',
    label           : bool              = False,
    sequence_flag   : bool              = True,
    hide_rows       : bool              = True,
    hide_columns    : bool              = False,
    print_flag      : bool              = False
) -> None:

    n = len(TA)
    x_coords = range(n)


    fig_height_in = 0.59  + 2
    fig, axs = plt.subplots(1, 1, figsize=(12, fig_height_in), sharex=True)


    axs.plot(x_coords, TA, label='TA')
    i = sequence_i
    axs.plot(
        x_coords[i:i+subsequence_len], TA[i:i+subsequence_len],
        color=color,
        label='Subsequence' if i == 0 else ""
      )
    axs.legend()
    axs.set_title('Subsequence_' + str(i) +"_"+str(subsequence_len))

    if dots:
      plt.scatter(x_coords, TA, color=dots_color)
      if label:
        subsequence_x = x_coords[sequence_i:sequence_i + subsequence_len]
        subsequence_y = TA[sequence_i:sequence_i + subsequence_len]
        for x, y in zip(subsequence_x, subsequence_y):
            axs.text(x, y+0.3, f'{y:.2f}', color=dots_color, fontsize=8, ha='center', va='bottom')  # Añade el valor sobre el punto
    plt.tight_layout()
    plt.show()
    if sequence_flag : show_sequence([TA[sequence_i:sequence_i + subsequence_len]], hide_rows, hide_columns)

# %% ../nbs/mplots.ipynb 27
class GD_Mat:
    def __init__(self, id,  name, data_path = '~/data'):
        self.id                 = id #GD id
        self.data_path          = os.path.expanduser(data_path) # Local data path
        self.zip_path           = os.path.join(self.data_path, name + '.zip')
        self.mat_path           = os.path.join(self.data_path, name + '.mat')
        self.mats_files         = None
        self.mats               = None #Downloaded matlab matrices
        self.mats_df            = None
        self.num_mats           = 0
        self.num_mats_extracted = 0
        
    def download_file_from_google_drive(self):
        return load.download_file_from_google_drive(self.id, self.zip_path)
        
    def get_mat_files(self):
        self.mats_files = [f for f in load.zip_contents(self.zip_path) if not f.startswith('__MACOSX/')]
        self.num_mats = len(self.mats_files)
        self.mats = self.mats_df = [None]*self.num_mats
    
    def unzip_mat(self, all_one, case = '', print_flag = False): 
        str = load.unzip_mat(all_one, self.zip_path, self.data_path, case, print_flag)
        self.get_mat_files()
        return str
        
    def mat2csv(self, case_id, print_flag = False):
        if print_flag: print("--> mat2csv", case_id)
        case = self.mats_files[case_id]
        case_path = os.path.join(self.data_path, case)
        print("Mat2csv case", case_path)
        self.mats_df[case_id] = load.mat2csv(case_path, self.data_path, print_flag)
        if print_flag: print("mat2csv", case_id, "-->")
        
    def __str__(self): 
        str = f"FileID: {self.id}\nData path: {self.data_path}\n"
        str += f"zip path: {self.zip_path}\nmat_files: {self.mats_files}"
        str +=f"\nnum_mats: {self.num_mats}"
        return str

# %% ../nbs/mplots.ipynb 28
@dataclass
class MatlabMatrix: 
    #File name
    filename : str = ""
    #Matrix name
    matname : str = ""
    #1-D numpy array with the time serie data
    data : List [ float ] = None
    #Length used for smoothing the time serie (if smoothed)
    smoothing_window_len : int = None
    #Wether if it has been smoothed yet or not 
    smoothed : bool = False
    path : str = None
    
    def load(
        self, 
        #Col in the matrix containing the time serie
        numcol : int, 
        #Wether to print messages for debugging or not
        print_flag : bool = False,
        force_smooth : bool = False,
        path = "."
    ) -> List [ float ] : 
        """ Reads the file and load the column numcol of the matrix as time series data. """
        
        if self.path is None:
            path = path

        dir = self.path + '/' + self.filename  + ".mat"
        
        dict = octave.load(dir)
        data = dict[self.matname]
        
        if print_flag: print(data.dtype)
        
        self.data = np.array(data[:,numcol])
        
        return self.data

    def smooth(
        self, 
        window_len=11, 
        print_flag = False,
        force_smooth = False
    ) -> List [ float ]:
        """ Applies moving average for smoothing the time serie data. """
        # window_len: smoothing window size needs, which must be odd number,
        
        if ( ( not self.smoothed ) or force_smooth ) :
            self.smoothed = True
        
            # Step 1: Apply the moving average to the main part of the data using convolution
        
            self.smoothing_window_len = window_len
        
            if self.smoothing_window_len % 2 == 0:
                warnings.warn("Window len must be odd! Adding 1 to your length.")
                self.smoothing_window_len += 1
            
            if print_flag: print("---> About to get out0")
            
            out0 = np.convolve(
                self.data, 
                np.ones(self.smoothing_window_len, dtype=int),
                'valid'
            ) / self.smoothing_window_len
        
            # Step 2: Handle the beginning of the array (start)
            # Use cumulative sum and then average it by the increasing window size
        
            if print_flag : 
                print("out0 ~", out0.shape)
                print("---> About to get start")
        
            r = np.arange(1, self.smoothing_window_len-1, 2)
        
            if print_flag: print("r", r)
        
            start = np.cumsum(self.data[:self.smoothing_window_len-1])[::2] / r
        
            if print_flag:
                print("start", start)
                print("---> About to get stop")
        
            # Step 3: Handle the end of the array (stop)
            # Reverse the array, use cumulative sum, and then average it by the increasing window size
        
            stop = (np.cumsum(self.data[:-self.smoothing_window_len:-1])[::2] / r)[::-1]
    
            if print_flag: 
                print("stop", stop)
        
            # Step 4: Combine the start, middle, and end parts together
            self.data = np.concatenate((start, out0, stop))
            return self.data

# %% ../nbs/mplots.ipynb 36
def find_dominant_window_sizes_list(
        X           : List [ float ], 
        nsizes      : int               = 1,
        offset      : float             = 0.05, 
        print_flag  : bool              = False
    ) -> List [ int ]:

    if print_flag:
        print( "-----> Find dominant_window_sizes_list -----" )
        print( "    X ~ ",  len(X) )
        print( "    Looking for - at most - the best", nsizes, "window sizes")
        print( "    Offset", offset, "max size:", offset*len(X))
        
    fourier = np.absolute(np.fft.fft(X))
    freqs = np.fft.fftfreq(X.shape[0], 1)

    coefs = []
    window_sizes = []

    for coef, freq in zip(fourier, freqs):
        if coef and freq > 0:
            coefs.append(coef)
            window_sizes.append(1 / freq)

    coefs = np.array(coefs)
    window_sizes = np.asarray(window_sizes, dtype=np.int64)

    idx = np.argsort(coefs)[::-1]
    sorted_window_sizes = window_sizes[idx]

    # Find and return all valid window sizes
    valid_window_sizes = [
        int(window_size / 2) for window_size in sorted_window_sizes
        if 20 <= window_size < int(X.shape[0] * offset)
    ]

    # If no valid window sizes are found, return the first from sorted list
    if not valid_window_sizes:
        sizes = [sorted_window_sizes[0] // 2][:nsizes]
    else:
        sizes = valid_window_sizes[:nsizes]
    
    if print_flag:
        print("    Sizes:", sizes)
        print( "----- Find dominant_window_sizes_list ----->" )
    
    return sizes

# %% ../nbs/mplots.ipynb 40
def plot_subsequences_aux(
    ax              : plt.Axes, 
    x_coords        : List[ int ],  
    TA              : List [ float ], 
    subsequence_len : int, 
    i               : int   = 0, 
    distance        : float = 0, 
    print_flag      : bool  = False
) -> None:
    ax.clear()
    ax.plot(x_coords, TA, label='TA')
    if print_flag:
        print("TA[" + str(i) + "] start ", i, "end", i+subsequence_len)
    ax.plot(x_coords[i:i+subsequence_len], TA[i:i+subsequence_len], color='green', label='Subsequence' if i == 0 else "")
    ax.text(i + subsequence_len/2, (min(TA[i:i+subsequence_len]) + max(TA[i:i+subsequence_len])) / 2, f"{distance}", ha='center')
    ax.legend()
    ax.set_title('Euclidean distance ' + str(i))

def plot_subsequences(
    TA                  : List [ float ], 
    TB                  : List [ float ], 
    reference_i         : int,
    subsequence_len     : int, 
    distances           : List [ float ], 
    print_flag          : bool              = False,
    fig_size            : Tuple[int, int]   = (12, 10)
) -> None:
    n = len(TA)
    x_coords = range(n)
    current_index = 0

    fig, (ax0, axN) = plt.subplots(
        2, 1, figsize=fig_size, sharex=True
    )

    # Plot the ax0 always on top
    if print_flag: print("--> Plotting ax0")
    ax0.plot(x_coords, TA, label='Time Series')
    if print_flag: print("adding TB ", subsequence_len, len(TB))
    ax0.plot(x_coords[reference_i:reference_i+subsequence_len], TB, color='darkgray', label='TB_reference')
    if print_flag: print("TB added")
    ax0.legend()
    ax0.set_title('Pairwise differences')
    if print_flag: print("Plotting ax0 done -->")
    # Function to handle button click to go to the next plot
    def on_next_clicked(b):
        nonlocal current_index
        if current_index < len(distances) - 1:
            current_index += 1
            plot_subsequences_aux(axN, x_coords, TA, subsequence_len, current_index, distances[current_index], print_flag)
            plt.tight_layout()
            plt.draw()

    # Function to handle button click to go to the previous plot
    def on_prev_clicked(b):
        nonlocal current_index
        if current_index > 0:
            current_index -= 1
            plot_subsequences_aux(axN, x_coords, TA, subsequence_len, current_index, distances[current_index], print_flag)
            plt.tight_layout()
            plt.draw()

    # Initialize the first subsequence plot
    plot_subsequences_aux(axN, x_coords, TA, subsequence_len, current_index, distances[current_index], print_flag)

    # Create and display prev/next buttons
    prev_button = widgets.Button(description='Previous')
    next_button = widgets.Button(description='Next')
    prev_button.on_click(on_prev_clicked)
    next_button.on_click(on_next_clicked)
    buttons = widgets.HBox([prev_button, next_button])
    display(buttons)

# %% ../nbs/mplots.ipynb 41
def plot_dataFrame(title, df, vars = [], interval = 10000):
    if len(vars) > 0:
        num_vars = len(df.columns)
    
        for var_num in vars:
            if var_num >= len(df.columns):
                raise ValueError("var_num "+var[var_num] + "is out of the range of DataFrame columns: " + num_vars)

        num_vars = len(vars)
        
        ### Start the plot 

        #fig = plt.figure(figsize=(10, num_intervals * 3))  # Ajusta el tamaño del plot según el número de intervalos
        
        num_intervals = df.shape[0] // interval + 1
        fig = plt.figure(figsize=(10, num_vars * num_intervals * 3))  ## Size
        gs = GridSpec(num_intervals*num_vars, 1) # 1 column, len(vars) rows
        var_pos = 0
        for var_num  in vars:
            var_name = df.columns[var_num]
            data = df[var_name]
            for i in range(num_intervals):    
                start_idx = i * interval
                end_idx = len(data) if i == (num_intervals - 1) else start_idx + interval
                ax = fig.add_subplot(gs[var_pos+i])
                ax.plot(np.arange(start_idx, end_idx), data[start_idx:end_idx], label=f"{var_name} [{start_idx}, {end_idx}]")
                ax.set_title(f"{var_name} [{start_idx}, {end_idx}]")
                ax.set_xlabel("Time")
                ax.set_ylabel(var_name)
                ax.legend()
            var_pos += 1
                
        plt.suptitle(title, fontsize=16)
        plt.tight_layout()
        plt.show()
    else: raise ValueError("No variable proposed for plotting")

# %% ../nbs/mplots.ipynb 42
def plot_dataFrame_compareSubsequences(
    title, df, var, subsequence_len, seq1_init, seq2_init, 
    title_fontsize = '30',
    others_fontsize='20'
):
    fig, axs = plt.subplots(2)
    fig.subplots_adjust(hspace=0.4) 
    plt.suptitle(title, fontsize=title_fontsize)
    var_name = df.columns[var]
    axs[0].set_ylabel(var_name, fontsize=others_fontsize)
    axs[0].plot(df[var_name], alpha=0.5, linewidth=1)
    axs[0].plot(df[var_name].iloc[seq1_init:seq1_init+subsequence_len])
    axs[0].plot(df[var_name].iloc[seq2_init:seq2_init+subsequence_len])
    rect = Rectangle((seq1_init, 0), subsequence_len, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    axs[0].set_xlabel("Index", fontsize=others_fontsize)

    rect = Rectangle((seq2_init, 0), subsequence_len, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    axs[1].set_xlabel("Relative Index (subsequence)", fontsize=others_fontsize)
    axs[1].set_ylabel(var_name, fontsize=others_fontsize)
    axs[1].plot(df[var_name].values[seq1_init:seq1_init+subsequence_len], color='C1')
    axs[1].plot(df[var_name].values[seq2_init:seq2_init+subsequence_len], color='C2')
    plt.show()
    

# %% ../nbs/mplots.ipynb 44
def df_plot_colored_variables(df):
    # Show time series plot
    fig, ax = plt.subplots(1, figsize=(15,5), )
    cmap = matplotlib.colormaps.get_cmap('viridis')
    #df.plot(color=cmap(0.05), ax=ax) # or use colormap=cmap
    df.plot(colormap=cmap, ax=ax) # or use colormap=cmap
    # rect = Rectangle((5000, -4.2), 3000, 8.4, facecolor='lightgrey', alpha=0.5)
    # ax.add_patch(rect)
    plt.tight_layout()
    plt.legend()
    display(plt.show())

# %% ../nbs/mplots.ipynb 45
def plot_df_with_intervals_and_colors(title, df, interval=10000):
    num_variables = len(df.columns)
    num_intervals = len(df) // interval + 1  # Calcula el número necesario de intervalos/subplots

    fig = plt.figure(figsize=(10, num_intervals * 3 * num_variables))  # Ajusta el tamaño del plot
    gs = GridSpec(num_intervals * num_variables, 1)
    
    cmap = matplotlib.colormaps.get_cmap('viridis')

    for var_num, var in enumerate(df.columns):
        data = df[var]
        for i in range(num_intervals):
            ax = fig.add_subplot(gs[var_num * num_intervals + i])
            start_idx = i * interval
            end_idx = start_idx + interval

            if i == num_intervals - 1:  # Ajusta el último intervalo para incluir todos los datos restantes
                end_idx = len(data)

            color = cmap(var_num / num_variables)  # Asigna un color basado en la variable
            ax.plot(np.arange(start_idx, end_idx), data[start_idx:end_idx], label=f"{var} [{start_idx}, {end_idx}]", color=color)
            ax.set_title(f"{var} [{start_idx}, {end_idx}]")
            ax.set_xlabel("Index")
            ax.set_ylabel(var)
            ax.legend()

    plt.suptitle(title, fontsize=16)
    plt.tight_layout()
    plt.show()

# %% ../nbs/mplots.ipynb 47
def make_symmetric_(
        mat : List [ float ]
    ) -> None:
    """ Ensures down-left triangle equals to up-right triangle """
    for i in range(len(mat)):
       mat[i:,i] = mat[i,i:]
def check_symmetric(
        mat : List [ float ]
    ) -> bool:
    """ Check wether if down-left triangle equals to up-right triangle """
    sym = True
    i = 0
    while (i < len(mat) and sym):
        sym = np.array_equal(mat[i:,i], mat[i,i:])
        i+=1
    return sym


# %% ../nbs/mplots.ipynb 50
def moving_mean(a, w):
  result = np.zeros((len(a) - w + 1,))
  p = a[0]
  s = 0
  for i in range(1, w):
    x = p + a[i]
    z = x - p
    s += (p - (x - z)) + (a[i] - z)
    p = x
  
  result[0] = (p + s) / w

  for i in range(w, len(a)):
    x = p - a[i - w]
    z = x - p
    s += (p - (x - z)) - (a[i - w] + z)
    p = x

    x = p + a[i]
    z = x - p
    s += (p - (x - z)) + (a[i] - z)
    p = x
    result[i - w + 1] = (p + s) / w

  return result
def sum_of_squared_differences(a, means, w):
  result = np.zeros((len(a) - w + 1,))
  for i in range(len(a) - w + 1):
    vals = a[i:i+w] - means[i]
    vals = vals * vals
    result[i] = np.sum(vals)
  return result
def get_precomputes(T, m, nanvalues):
  flatness_epsilon = 1e-13
  n = len(T) - m + 1;
  df = np.zeros((n,))
  dg = np.zeros((n,))

  means = moving_mean(T,m)

  norms = sum_of_squared_differences(T, means, m)

  for i in range(n):
    if nanvalues[i]:
      norms[i] = np.nan
    elif norms[i] <= flatness_epsilon:
      norms[i] = np.nan
    else:
      norms[i] = 1.0 / math.sqrt(norms[i])

  for i in range(n-1):
    df[i] = (T[i + m] - T[i]) / 2.0;
    dg[i] = (T[i + m] - means[i + 1]) + (T[i] - means[i]);

  return means, norms, df, dg
def convert_non_finite_to_zero(T, m):
  timeseries_clean = np.zeros((len(T),))
  nanvals = np.zeros((len(T) - m + 1,))
  steps_since_last_nan = m
  for i in range(len(T)):
    if np.isfinite(T[i]):
      timeseries_clean[i] = T[i]
    else:
      steps_since_last_nan = 0
      timeseries_clean[i] = 0
    if i >= m - 1:
      nanvals[i - m + 1] = steps_since_last_nan < m
    steps_since_last_nan += 1
  return timeseries_clean, nanvals
# Computes the distance matrix using the diagonal update method used in SCAMP
def distance_matrix(a,b,w):
    has_b = True
    if b is None:
        has_b = False
        b = a
    na = len(a) - w + 1
    if not has_b:
        nb = na
    else:
        nb = len(b) - w + 1
    out = np.ones((nb,na)) * -2


    a, nan_a = convert_non_finite_to_zero(a,w)
  
    if has_b:
      b, nan_b = convert_non_finite_to_zero(b,w)
    else:
      b = a

    mua, siga, dfa, dga = get_precomputes(a,w,nan_a)
    if not has_b:
        mub = mua
        sigb = siga
        dfb = dfa
        dgb = dga
    else:
        mub, sigb, dfb, dgb = get_precomputes(b,w, nan_b)

    diagmax = na
    if not has_b:
        minlag = w // 4
    else:
        minlag = 0

    
    c = np.zeros((diagmax - minlag,)) 
    for diag in range(minlag,diagmax):
      c[diag-minlag] = np.sum((a[diag:diag+w]-mua[diag]) * (b[:w]-mub[0]))
    
    for offset in range(nb-minlag):
      result = c*(sigb[offset]*siga[minlag+offset:])
      out[offset, minlag+offset:] = result
      if not has_b:
        out[minlag+offset:, offset] = result
      x = c + dfb[offset] * dga[minlag+offset:] + dfa[minlag+offset:]*dgb[offset]
      c = x[:-1]
    if has_b:
      diagmax = nb
      c = np.zeros((diagmax - minlag,)) 
      for diag in range(minlag,diagmax):
        c[diag-minlag] = np.sum((b[diag:diag+w]-mub[diag]) * (a[:w]-mua[0]))
      for offset in range(na-minlag):
        result = c*(siga[offset]*sigb[minlag+offset:])
        out[minlag+offset:, offset] = result
        x = c + dfa[offset] * dgb[minlag+offset:] + dfb[minlag+offset:]*dga[offset]
        c = x[:-1]

    out[np.isnan(out)] = -2
    return out

# %% ../nbs/mplots.ipynb 52
@dataclass
class DistanceProfile:
    """ Vector of distances between each subsequence in TA and a reference sequence TB"""
    # Data to compare
    data            : List [ float ]= None
    # Reference data
    data_b          : List [ float ]= None
    data_b_i        : int           = 0
    self_join       : bool          = True
    subsequence_len : Optional[int] = None
    # Distance profile
    distances: List[float]          = field(default_factory=list),
    # Figure
    mplot                           = None,
    # Method used for building the DistanceProfile
    method                          = 'naive',
    computation_time: float         = 0.0
    dominant_lens   : List[ int ]   = None
    def provide_lens(
        self        : 'DistanceProfile',
        nlens       : int               = 1,
        offset      : float             = 0.05,
        print_flag  : bool              = False
    ) -> List [ int ]:
        if nlens == 1:
            self.subsequence_len = find_dominant_window_sizes(self.data, offset = offset)
            self.dominant_lens = [self.subsequence_len]
        else:
            self.dominant_lens = find_dominant_window_sizes_list(
                self.data,
                nsizes      = nlens,
                offset      = offset,
                print_flag  = print_flag
            )
            self.subsequence_len = self.dominant_lens[0]
    
    def compute(
        self            : 'DistanceProfile',
        d               : Callable          = euclidean_distance,
        method          : str               = 'naive',
        fig_size        : tuple             = (12, 10),
        print_flag      : bool              = False,
        plot_flag       : bool              = True,
        time_flag       : bool              = False,
        ensure_symetric : bool              = False,
        provide_len     : bool              = True,
        nlens           : Optional [ int ]  = 1
    ) -> Tuple[ List [ float ], ut.Time ]:
        """ Compute the Distance Profile """    
        t = None
        if time_flag:
            t = ut.Time(function=ut.funcname())
            t.start(print_flag)
        

        if self.subsequence_len is None:
            if provide_len or self.data_b is None:
                self.provide_lens(nlens = nlens, print_flag = print_flag)
            else:
                self.subsequence_len = len(self.data_b)
        
        if (self.self_join): 
            if print_flag : print("--> Self join", "TB_i", self.data_b_i, "TA", self.data)
            self.data_b = self.data[self.data_b_i:self.data_b_i+self.subsequence_len]

        if print_flag:
            print("TA: ", self.data)
            print("TB: ", self.data_b)
        

        n = len(self.data)
        m = self.subsequence_len
        expected_size = n - m + 1

        if print_flag: print("Expected_size", expected_size)
        self.method = method
        match self.method:
            case 'stumpy.mass':
                if print_flag: print("--> Using stumpy.mass")
                if (d.__name__ == 'z_normalized_euclidean_distance'):
                    if print_flag: print("Normalized")
                    self.distances = stump.core.mass(
                        Q = self.data_b.astype(np.float64),
                        T = self.data.astype(np.float64)
                    )
                else:
                    if print_flag: print("Non-Normalized")
                    self.distances = stump.core.mass(
                        Q = self.data_b.data.astype(np.float64),
                        T = self.data.astype(np.float64),
                        normalize = False
                    )
            case _:
                print("--> Using naive made distance profile [ default | Not recommended ]")
                self.distances = np.zeros(expected_size)
                for i in range(expected_size):
                    vector_a = self.data_b
                    vector_b = self.data[i:i+m]
                    if print_flag: 
                        print(f"[DP] Computing distance {i} \nTA: {self.data},\nTB: {self.data_b}")
                    self.distances[i] = d (
                        vector_a    = vector_a,
                        vector_b    = vector_b,
                        print_flag  = print_flag,
                        time_flag   = time_flag
                    )[0]


                #self.distances = np.array([
                #    d(
                #        vector_a = deepcopy(self.data_b),
                #        vector_b = deepcopy(self.data[i:i+m]),
                #        print_flag = print_flag,
                #        time_flag = time_flag
                #    )
                #    [0] for i in range(expected_size)
                #]
                #)
        if (ensure_symetric):
            make_symmetric_(self.distances)
            
        if (self.self_join):
            if print_flag: print("--> Self join")
            self.distances[self.data_b_i] = np.nan
            
        if plot_flag: 
            if print_flag: print("--> plot")
            plot_subsequences(
                self.data,
                self.data_b,
                self.data_b_i, 
                len(self.data_b), 
                self.distances,
                fig_size = fig_size
            )
        if time_flag: 
            t.end(print_flag)
            t.show()
            self.computation_time = t.time_total
        return self.distances, t
    
    def plot_subsequence_compared(
        self,
        sequence_i : int = 0,
        print_flag : bool = False,
        fig_width = 12
    ) -> None:
        if (self.data_b is None or self.self_join) :
            if print_flag: print("--> TB = TA")
            self.data_b = self.data
        n = len(self.data)
        m = self.subsequence_len
        expected_size = n - m + 1
        x_coords = range(n)
        if print_flag:
            print("expected size", expected_size)
            print("--> Getting height")
        fig_height_in = 0.59 *2 + 2
        fig, axs = plt.subplots(2, 1, figsize=(fig_width, fig_height_in), sharex=True)
        if print_flag: print("--> TB")
        TB_sub = self.data_b[self.data_b_i: m]
        if print_flag: print("TA", self.data, len(self.data))
        if print_flag: print("TB", self.data_b, len(self.data_b), " subsequence ", self.data_b_i, m, TB_sub)
        axs[0].plot(x_coords, self.data_b, label='Time Series')
        if print_flag : print("m", m, "TB_i", self.data_b_i, "TB_i+m", self.data_b_i+m)
        axs[0].plot(x_coords[self.data_b_i:self.data_b_i+m], TB_sub, color='darkgray', label='TB_reference')
        axs[0].legend()
        axs[0].set_title('Pairwise differences')

        if print_flag: print("--> TA")
        axs[1].plot(x_coords, self.data, label='TA')
        i = sequence_i
        axs[1].plot(x_coords[i:i+m], self.data[i:i+m], color='green', label='Subsequence' if i == 0 else "")
        axs[1].text(i + m/2, (min(self.data[i:i+m]) + max(self.data[i:i+m])) / 2, f"{self.distances[i]:.2f}", ha='center')
        axs[1].legend()
        axs[1].set_title('Euclidean distance ' + str(i))
        plt.tight_layout()
        plt.show()

# %% ../nbs/mplots.ipynb 60
@dataclass
class DistanceMatrix: 
    """ Similarity matrix """
    # -- Similarity Matrix
    distances       : List[ List [ float ] ]    = field(default_factory=list)
    # -- Time series A (Query Time Serie
    data            : List [ float ]            = None
    # -- Reference sequence
    data_b          : Optional[ List [ float ]] = None
    ## -- If comparing to a subsequence of the own matrix
    self_join       : bool                      = True
    data_b_i        : int                       = 0
    # -- 
    subsequence_len : Optional[ int ]           = None
    method          : str                       = 'naive'
    computation_time: float                     = 0.0
    dominant_lens   : List[ int ]               = None

    def provide_lens(
        self        : 'DistanceMatrix',
        nlens       : int               = 1,
        offset      : float             = 0.05,
        print_flag  : bool              = False
    ) -> List [ int ]:
        if nlens == 1:
            self.subsequence_len = find_dominant_window_sizes(self.data, offset = offset)
            self.dominant_lens = [self.subsequence_len]
        else:
            self.dominant_lens = find_dominant_window_sizes_list(
                self.data,
                nsizes      = nlens,
                offset      = offset,
                print_flag  = print_flag
            )
            self.subsequence_len = self.dominant_lens[0]

    def load_data_from_matlab(
        self, 
        matrix : MatlabMatrix = None,
        filename : str = None,
        matname : str = None,
        smoothing_window_len : int = None,
        path : str = ".",
        numcol : int  = 0,
        force_smooth : bool = False,
        set_a_or_b : bool = True,
        print_flag : bool = False
    ) ->  List [ float ] :
        if matrix is None:
            matrix = MatlabMatrix(
                filename = filename, 
                matname = matname,
                smoothing_window_len = smoothing_window_len,
                path = path
            )
        matrix_data = matrix.load(
            numcol, print_flag, force_smooth, path
        )

        if (set_a_or_b):   
            if print_flag: print("Copy A")
            self.data = deepcopy(matrix_data)
        else: 
            if print_flag: print("Copy B")
            self.data_b = deepcopy(matrix_data)

        return matrix_data
        
    
    def compute(
        self                : 'DistanceMatrix',
        method              : 'str'     = 'naive',
        d                   : Callable  = z_normalized_euclidean_distance,
        ensure_symetric     : bool      = True,
        #--- Scamp
        mheight             : int       = None,
        mwidth              : int       = None,
        #--- Octave functions expected parameters ---
        min_lag             : int       = 0, #May be needed if SimMat is used
        #--- may be needed by runsplat, splat & piecewiseSplat
        multiresolution     : int       = 0,
        calibration         : int       = 0,
        piecewise           : bool      = False,
        patch_size          : int       = 5000, #Size of patches to compute (the final matrix, similar to mheight, mwidht)
        print_flag          : bool      = False,
        plot_flag           : bool      = False,
        time_flag           : bool      = True,
        allow_experimental  : bool      = True, #Allows the use of experimental code
        parallel            : bool      = True,
        threads             : int       = 4,
        provide_len         : bool      = True,
        nlens               : int       = 1
    ) -> Tuple [ List [ List [ float ] ], Optional [ ut.Time ] ] :
        t = None

        complete                    = self.data_b == None
        n                           = len(self.data)
        if self.subsequence_len is None:
            if provide_len or self.data_b is None:
                self.provide_lens(nlens = nlens, print_flag = print_flag)
            else:
                self.subsequence_len = len(self.data_b)
        rows = n - self.subsequence_len + 1
        if (complete): 
            columns = rows
            reference_seq = self.data
        else: 
            reference_seq = self.data_b
            columns = len(reference_seq) + 1
        self.distances = np.empty((rows, columns))
        if time_flag: 
            timer = ut.Time()
            timer.start()

        DP_AB : DistanceProfile = None

        match method:
            case 'stump':
                if print_flag: print("--> Stump")
                if self.data_b is None: 
                    data_b = deepcopy(self.data)
                else: 
                    data_b = deepcopy(self.data_b)
                DP_AB = DistanceProfile(self_join = self.self_join, subsequence_len = self.subsequence_len )
                if not parallel:
                    print ("Not parallel")
                    DP_AB.data            = self.data
                    DP_AB.data_b          = deepcopy(data_b)
                    DP_AB.data_b_i        = 0
        
                
                def compute_distance_i(i : int) -> List [ float ]:
                    nonlocal DP_AB

                    if parallel:
                        if print_flag: print(f"Creating {i} ~ DP_AB")
                        DP_AB_ = DistanceProfile(
                            data            = deepcopy(self.data),
                            data_b          = deepcopy(data_b),
                            data_b_i        = i,
                            self_join       = self.self_join, 
                            subsequence_len = self.subsequence_len
                        )
                        if print_flag: 
                            print(f"data {i} ~ {DP_AB_.data.shape}")
                            print(f"data_b {i} ~ ", DP_AB_.data_b.shape)
                    else:
                        DP_AB_ = DP_AB
                        DP_AB_.data_b_i = i
                        DP_AB.data_b = data_b

                    DP_AB_.compute(
                        print_flag=print_flag,
                        plot_flag=plot_flag,
                        d=d,
                        method='stumpy.mass',
                    )

                    if print_flag:
                        print(f"DP {i} = {DP_AB_.distances}")
                        print(f"DP {i} ~ {DP_AB_.distances.shape}")
                    
                    return DP_AB_.distances
                
                if (parallel):
                    if print_flag: print("Parallel")
                    with ThreadPoolExecutor(max_workers=threads) as executor:
                        distances = list(executor.map(compute_distance_i, range(rows)))
                    self.distances = np.array(distances)
                else:
                    for i in range(rows):
                        if print_flag: print(f"[ DistanceMatrix ] | Compute row {i} / {rows} stump")
                        self.distances[i] = compute_distance_i(i)
                        
            case 'scamp': 
                if print_flag: print("--> Scamp")
                if complete and allow_experimental:
                    if print_flag: 
                        print("--> selfjoin_matrix", self.distances.shape)

                    if mheight is None: 
                        mheight = n - self.subsequence_len + 1
                    if mwidth is None:
                        mwidth =  n - self.subsequence_len + 1
                    self.distances = scamp.selfjoin_matrix(
                        self.data, 
                        self.subsequence_len,
                        gpus    = [],
                        mheight = mheight,
                        mwidth  = mwidth,
                        verbose = print_flag,
                        pearson = True
                    )
                    if print_flag: print("selfjoin_matrix -->", self.distances.shape)
                else:
                    self.distances = distance_matrix(
                            self.data, #a_data
                            reference_seq,  #b_data
                            self.subsequence_len #windos
                        )
            case 'octave-mpx':
                self.distances = octave.SimMat(
                    self.data,
                    self.subsequence_len,
                    self.data_b,
                    min_lag,
                    nout=1
                )
            case 'octave-runsplat':
                self.distances = octave.runsplat(
                    self.subsequence_len,
                    self.data, 
                    self.data_b,
                    multiresolution, 
                    calibration, 
                    display_mplot = False,
                    piecewise = True, 
                    patch_size = patch_size
                )
            case 'octave-splat':
                print("multiresolution before octave call", multiresolution)
                args = {
                    'timeSeriesA': self.data, 
                    'subseqLen': self.subsequence_len,
                    'timeSeriesB': self.data_b, 
                    #displat_mplot setted up to false as default because I couldn't get the plot shown in Jupyter Notebook... waiting for python implementation. (Zack!)
                    'plotting': False,
                    'multiresolution': multiresolution,
                    'calibration': calibration
                }
                self.distances = octave.SPLAT(
                    self.data, self.subsequence_len, 
                    self.data_b, False, 
                    multiresolution, calibration
                )
            case 'octave-piecewiseSplat':
                self.distances = octave.piecewiseSplat(
                    self.data,
                    self.subsequence_len, 
                    patch_size,
                    False, 
                    self.data_b
                )
            case _: #default naive
                if print_flag: print("--> Invalid method. Using naive [default]")
                if ( self.self_join ) : self.data_b = deepcopy(self.data)

                DP_AB = DistanceProfile(
                    data        = deepcopy(self.data),
                    data_b      = deepcopy(self.data_b),
                    self_join   = self.self_join, 
                    subsequence_len = self.subsequence_len
                )

                for i in range(rows):
                    DP_AB.data_b   = deepcopy(self.data_b)
                    DP_AB.data_b_i = i

                    if print_flag: 
                        print( f"[ DistanceMatrix ] | Compute row {i}" )
                        print( f"TA{DP_AB.data}" )
                        print( f"TB{DP_AB.data_b}" ) 
                        print( f"len{DP_AB.subsequence_len}" )
                    
                    DP_AB.compute (
                        print_flag = print_flag,
                        plot_flag  = plot_flag,
                        d          = d,
                        method     = 'naive',

                    )
                    self.distances[i] = DP_AB.distances
                        
        if time_flag: 
            timer.end()
            self.computation_time = timer.duration() 
        if print_flag: 
            if time_flag: 
                print(f"matrix profile {self.computation_time} seconds -->")
            else: 
                print("matrix profile -->")
        #TODO: En mplot_explorer se asegura de que la matriz sea simétrica respecto a la diagonal
        # y tiene sentido, cuando es cuadrada, pero.... siendo así... 
        # ¿Por qué la guardo entera? Ya he guardado antes matrices simétricas como triangulares...
        # -> Pensar en cómo afectaría. Tiene sentido para el caso en que rows = columns.
        if (ensure_symetric and rows == columns) : 
            make_symmetric_(self.distances)
        return self.distances    

# %% ../nbs/mplots.ipynb 64
def plot_motif(df, motif_idx, nearest_neighbor_idx, variable_name, title, padding = 1000, m = 1, mp = None):
    fig, axs = plt.subplots(2, sharex = True, gridspec_kw={'hspace': 0})
    plt.suptitle('Motif (Pattern) Discovery', fontsize='30')
    padding = min(padding, len(df[variable_name].values) // 2)

    # Calcula los límites para hacer zoom
    x_min = max(min(motif_idx, nearest_neighbor_idx) - padding, 0)
    x_max = min(max(motif_idx, nearest_neighbor_idx) + padding, len(df[variable_name].values))

    axs[0].plot(df[variable_name].values)
    axs[0].set_xlim([x_min, x_max])  # Aplica el zoom aquí
    axs[0].set_ylabel(title, fontsize='20')
        
    axs[0].set_ylabel(title, fontsize='20')
    rect = Rectangle((motif_idx, 0), m, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    rect = Rectangle((nearest_neighbor_idx, 0), m, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    axs[1].set_xlabel('Time', fontsize ='20')
    axs[1].set_ylabel('Matrix Profile', fontsize='20')
    axs[1].axvline(x=motif_idx, linestyle="dashed")
    axs[1].axvline(x=nearest_neighbor_idx, linestyle="dashed")
    axs[1].plot(mp)
    plt.show()

# %% ../nbs/mplots.ipynb 65
def plot_motif_separated(df, motif_idx=0, nearest_neighbor_idx=0, variable_name="", title="", padding=1000, m=1, mp=None):
    fig, axs = plt.subplots(4, sharex=False, figsize=( 12, 5), gridspec_kw={'hspace': 0.5})
    plt.suptitle('Motif (Pattern) Discovery', fontsize='20')
    
    padding = max(m, min(padding, len(df[variable_name].values) // 2))

    x_min_motif = max(motif_idx - padding, 0)
    x_max_motif = min(motif_idx + padding, len(df[variable_name].values))

    axs[0].plot(df[variable_name].values)
    axs[0].set_xlim([x_min_motif, x_max_motif])
    axs[0].set_ylabel(title, fontsize='10')
    rect_motif = Rectangle((motif_idx, df[variable_name].min()), m, df[variable_name].max() - df[variable_name].min(), facecolor='lightgrey')
    axs[0].add_patch(rect_motif)

    axs[1].plot(mp)
    axs[1].set_xlim([x_min_motif, x_max_motif])
    axs[1].set_xlabel('Time', fontsize='10')
    axs[1].set_ylabel('MP - Min', fontsize='10')
    axs[1].axvline(x=motif_idx, linestyle="dashed")

    x_min_neighbor = max(nearest_neighbor_idx - padding, 0)
    x_max_neighbor = min(nearest_neighbor_idx + padding, len(df[variable_name].values))

    axs[2].plot(df[variable_name].values)
    axs[2].set_xlim([x_min_neighbor, x_max_neighbor])
    axs[2].set_ylabel(title, fontsize='10')
    rect_neighbor = Rectangle((nearest_neighbor_idx, df[variable_name].min()), m, df[variable_name].max() - df[variable_name].min(), facecolor='lightgrey')
    axs[2].add_patch(rect_neighbor)

    axs[3].plot(mp)
    axs[3].set_xlim([x_min_neighbor, x_max_neighbor])
    axs[3].set_xlabel('Time', fontsize='10')
    axs[3].set_ylabel('MP-max', fontsize='10')
    axs[3].axvline(x=nearest_neighbor_idx, linestyle="dashed")

    plt.show()

# %% ../nbs/mplots.ipynb 66
@dataclass
class MatrixProfile:
    """ Class for better usability of Matrix Profile inside deepVATS"""
    #---- Main information of the matrix profile ----#
    data        : List [ float ] = None
    data_b      : List [ float ] = None
    self_join   : bool           = True
    distances   : List[ float ]  =  field(default_factory=list)

    # Execution information
    computation_time: float = 0.0
    
    #-- Size used for the MP computation
    subsequence_len: int = 0
    #-- Wether if stumpy or SCAMP or other method have been used 
    method: str = 'naive'
    #-- Interactive Plot
    current_index_pos_plot  : int  = 0

    
    #-- Looking for motifs & neighbors
    # Ordered array for finding motifs/anomalies
    index : List[int]       =  field(default_factory=list)
    # Nearest neighbours in the past (if computed)
    index_left : List[int]  =  field(default_factory=list)
    # Nearest neighbours in the future (if computed)
    index_right: List[int]  = field(default_factory=list)

    #--- Save the main motif index and its neighbors' index    
    motif_idx                       : int = 0
    motif_nearest_neighbor_idx      : int = 0
    motif_nearest_neighbor_idx_left : int = 0
    motif_nearest_neighbor_idx_right: int = 0

    #--- Save the main anomaly index and its neighbors' index
    discord_idx                         : int = 0
    discord_nearest_neighbor_idx        : int = 0
    discord_nearest_neighbor_idx_left   : int = 0
    discord_nearest_neighbor_idx_right  : int = 0
    
    #-- Provided subsequence lengths
    dominant_lens : List[ int ] = None

    def plot(
        self        : 'MatrixProfile', 
        figsize     : Tuple [int, int]  = (10,8),
        plot_dots   : bool              = False,
        plot_ts     : bool              = True,
        print_flag  : bool              = False,
        ts_title    : str               = 'Time Series',
        mp_title    : str               = 'Matrix Profile'
    ):
        n           = len(self.data)
        x_coords    = range(n)
        y_coords    = self.data
        if plot_ts:
            fig, (ax1, ax2) = plt.subplots(
                2, 1, 
                figsize=figsize, 
                sharex=True
            )  

            ax1.plot(x_coords, y_coords, label='Time Series')
            if plot_dots:
                ax1.scatter(x_coords, y_coords, color='red') 
            ax1.set_title(ts_title)
            ax1.set_xlabel('Index (time)')
            ax1.set_ylabel('Value')

            ax2.plot(self.distances, label='Matrix Profile')
            ax2.set_title(mp_title)
            ax2.set_xlabel('Subsequence Index')
            ax2.set_ylabel('Distance')

            ax1.legend()
            ax2.legend()
            plt.tight_layout()
            plt.show()
        else:
            fig, (ax1) = plt.subplots(
                1, 1, 
                figsize=figsize, 
                sharex=True
            )  
            ax1.plot(self.distances, label='Matrix Profile')
            ax1.set_title('Matrix Profile')
            ax1.set_xlabel('Subsequence Index')
            ax1.set_ylabel('Distance')

            ax1.legend()
            plt.tight_layout()
            plt.show()
        
    def plot_interactive(
        self        : 'MatrixProfile', 
        figsize     : Tuple [ int, int ]  = (10, 4), 
        print_flag  : bool                = False
    ):
        
        self.current_index_pos_plot
        self.distances_ordered = np.argsort(self.distances)
    

        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=figsize, sharex=True)

        
        def update(pos : int = 0, add : int = 0):
            nonlocal print_flag 
            if print_flag: print("Before: Pos", pos, "Add", add)
            
            self.current_index_pos_plot = pos+add
            
            if (self.current_index_pos_plot < 0): self.current_index_pos_plot = len(self.distances) - 1
            if (self.current_index_pos_plot >= len(self.distances)): self.current_index_pos_plot = 0
            
            selected_index = self.distances_ordered[self.current_index_pos_plot]
            
            if print_flag: 
                print("After: Pos", self.current_index_pos_plot, "Selected index", selected_index)
                print("Distances: ", self.distances)
            
            ax1.clear()
            ax1.plot(self.distances, label='Matrix Profile')
            ax1.scatter(selected_index, self.distances[selected_index], color='red')

            ax1.text(0.5, 0.9, f'Posición actual: {self.current_index_pos_plot} de {len(self.distances_ordered) - 1}', horizontalalignment='center', verticalalignment='center', transform=ax1.transAxes)

            ax1.set_ylabel('Distance')
            ax1.legend()
            
            ax2.clear()
            ax2.plot(self.data, label='Time Series', color='lightgrey')
            ax2.axvline(x=selected_index, color='grey', linestyle='--')
            ax2.scatter(selected_index, self.data[selected_index], color='red')
            ax2.plot(range(selected_index, selected_index + self.subsequence_len),
                 self.data[selected_index:selected_index + self.subsequence_len],
                 color='orange', label=f'Subsequence {selected_index}')  # Subsecuencia en naranja
            ax2.set_xlabel('Index (time)')
            ax2.set_ylabel('Value')
            ax2.legend()
            
            ax2.set_xlabel('Index (time)')
            return pos

        
        first_button = widgets.Button(description='First Min => Motif')
        mid_button = widgets.Button(description='Mid')
        last_button = widgets.Button(description='Last Max => Discord')
        next_button = widgets.Button(description='Next')
        prev_button = widgets.Button(description='Previous')

        first_button.on_click(lambda b: update(0, 0))
        mid_button.on_click(lambda b: update(len(self.distances) // 2, 0))
        last_button.on_click(lambda b: update(-1,0))
        
        next_button.on_click(lambda b: update(self.current_index_pos_plot, 1))
        prev_button.on_click(lambda b: update(self.current_index_pos_plot, -1))

        display(
            widgets.VBox(
                [widgets.HBox([first_button, mid_button, last_button]),
                 widgets.HBox([prev_button, next_button])]
            )
        )

        update(0,0)

    def get_ordered_idx(self, pos):
        mp_sorted = np.argsort( self.distances )
        return mp_sorted[pos]
        
    def get_motif_idx(self : 'MatrixProfile', print_flag : bool = False): 
        motif_idx = self.get_ordered_idx(0)
        self.motif_idx = motif_idx
        if print_flag: print("motif id", motif_idx, "index ~ ", len(self.index))
        self.motif_nearest_neighbor_idx = self.index[motif_idx]
        
        if ( self.method == 'stump' or self.method == 'gpu_stump'):
            self.motif_nearest_neighbor_idx_left = self.index_left[motif_idx]
            self.motif_nearest_neighbor_idx_right = self.index_right[motif_idx]
        return self.motif_idx, self.motif_nearest_neighbor_idx, self.motif_nearest_neighbor_idx_left, self.motif_nearest_neighbor_idx_right
    
    def get_anomaly_idx(self : 'MatrixProfile', print_flag : bool = False ): 
        discord_idx = self.get_ordered_idx(-1)
        self.discord_idx = discord_idx
        self.discord_nearest_neighbor_idx = self.index[discord_idx]
        if print_flag: print("motif id", discord_idx, "index ~ ", len(self.index))
        if ( self.method == 'stump' or self.method == 'gpu_stump'):
            self.discord_nearest_neighbor_idx_left = self.index_left[discord_idx]
            self.discord_nearest_neighbor_idx_right = self.index_right[discord_idx]
            
        return self.discord_idx, self.discord_nearest_neighbor_idx, self.discord_nearest_neighbor_idx_left, self.discord_nearest_neighbor_idx_right
    
    def plot_id(
        self, 
        ta_name = 'Time Serie TA', 
        tb_name = 'Time Serie TB',
        idx = 0, 
        nearest_neighbor_idx = 0, 
        title_fontsize = '30', 
        other_fontsize = '20',
        figsize = (10, 8),
        title = 'Motif (Pattern) Discovery'
    ): 
        fig, axs = plt.subplots(3, sharex=True, gridspec_kw={'hspace': 0.4}, figsize = figsize)
        plt.suptitle(title + ' | ' + self.method , fontsize=title_fontsize)
        #--- Plot TA & Motif sequence
        axs[0].plot(self.data)
        axs[0].set_ylabel(ta_name, fontsize=other_fontsize)
        rect = Rectangle((idx, 0), self.subsequence_len, 40, facecolor='lightgrey')
        axs[0].add_patch(rect)
        #-- Plot TB & nearest neighbour sequence
        if (self.data_b is None):
            axs[1].plot(self.data)
        else: 
            axs[1].plot(self.data_b)
        axs[1].set_ylabel(tb_name, fontsize=other_fontsize)
        rect = Rectangle((nearest_neighbor_idx, 0), self.subsequence_len, 40, facecolor='lightgrey')
        axs[1].add_patch(rect)
        #--- Plot Matrix Profile
        axs[2].set_xlabel('Index', fontsize =other_fontsize)
        axs[2].set_ylabel('Matrix Profile', fontsize=other_fontsize)
        axs[2].axvline(x=idx, linestyle="dashed", color = "black")
        axs[2].axvline(x=nearest_neighbor_idx, linestyle="dashed", color="red")
        axs[2].plot(self.distances)
        plt.show()
    
    def provide_lens(
        self        : 'DistanceProfile',
        nlens       : int               = 1,
        offset      : float             = 0.05,
        print_flag  : bool              = False
    ) -> List [ int ]:
        if nlens == 1:
            self.subsequence_len = find_dominant_window_sizes(self.data, offset = offset)
            self.dominant_lens = [self.subsequence_len]
        else:
            self.dominant_lens = find_dominant_window_sizes_list(
                self.data,
                nsizes      = nlens,
                offset      = offset,
                print_flag  = print_flag
            )
            self.subsequence_len = self.dominant_lens[0]
    
    def __str__(self):
        return f"MP: {self.distances}\nIds: {self.index}\nIds_left: {self.index_left}\nIds_right: {self.index_right}\nComputation_time: {self.computation_time}\nsubsequence_len: {self.subsequence_len}\nmethod: {self.method}"

# %% ../nbs/mplots.ipynb 68
def matrix_profile(
    data            : List [ float ], 
    subsequence_len : Optional [ int ]              = None, 
    data_b          : Optional [ List [ float ] ]   = None,
    self_join       : bool                          = True,
    method          : str                           = 'naive', 
    d               : Callable                      = z_normalized_euclidean_distance,
    threads         : int                           = 4, # For scamp abjoin
    gpus            : int                           = [], # For scamp abjoin
    print_flag      : bool                          = False, 
    debug           : bool                          = True, 
    time_flag       : bool                          = True,
    plot_flag       : bool                          = False,
    provide_len     : bool                          = True,
    nlens           : int                           = 1
) -> Tuple [ List [ float ], List [ float ], List [ float], List[ float], Optional [ ut.Time ]]:
    """ 
    This function 
    Receives
    - data: a 1D-array representing a time series values (expected to be long)
    - subsequence_len: Matrix Profile subsequences length
    - method: wether to use stump or scamp algorithm
    - print_flag: for printing or not messages
    - debug: for adding some comprobations on GPUs usability
    - time_flag: for getting or not the execution time for the implementation analysis
    - Threads: number of threads for scamp multithread execution
    - GPUs: id of the GPUs to be used for scamp execution

    and returns 
    - mp: matrix profile
    - index: patterns indices
    - index_left: nearest neighbors in the past
    - index_right: nearest neigbhbors in the future
    - Optional: execution time
    """
    
    if print_flag: print("--> matrix profile")
    #Execution time
    duration = 0.0
    # Matrix Profile (distances)
    mp = []
    # Patterns indices (position within the MP)
    index = []
    index_left = []
    index_right = []

    
    #-- Start timing
    if time_flag: 
        timer = ut.Time()
        timer.start()

    #-- Select the method
    match method:
        case 'stump': # Not tested
            #-- use stumpy.gpu_stump
            normalize = (d.__name__ == 'z_normalized_euclidean_distance')
            if print_flag: 
                print("--> Stump (CPU)")
                print("MP | Compute | Using stumpy.stump | normalize?", normalize)
            
            mp = stump.stump(
                T_A = data.astype(np.float64), 
                m = subsequence_len, 
                T_B = data_b,
                ignore_trivial = True,
                normalize = normalize
            )
            #-- Save in separated columns for compatibility with SCAMP
            index = mp[:,1]
            index_left = mp[:,2]
            index_right = mp[:,3]
            mp = mp[:,0]
        
        case 'stump_gpu': # You are suposed to use this or scamp
            if print_flag: print("--> Stump (GPU)")
            #-- Matrix profile
            normalize = (d.__name__ == 'z_normalized_euclidean_distance')
            T_A = data.astype(np.float64)
            T_B = data_b
            if not T_B is None : 
                print("TB provided", T_B)
                T_B = T_B.astype(np.float64)
            mp = stump.gpu_stump(
                T_A = T_A, 
                m = subsequence_len, 
                T_B = T_B,
                ignore_trivial = True,
                normalize = normalize
            )
            #-- Save in separate columns
            index = mp[:,1]
            index_left = mp[:,2]
            index_right = mp[:,3]
            mp = mp[:,0]
            
        case 'scamp': # Yo should use GPU in Large TS
            if print_flag: print("--> Scamp")
            if debug: 
                print("Check gpu use")
                has_gpu_support = scamp.gpu_supported()
                print(has_gpu_support)
            #-- Matrix profile & index. Nothing more to save
            if (data_b is None):
                mp, index = scamp.selfjoin(data, subsequence_len)
            else: 
                if print_flag: print("--> data_b provided => Executing abjoin")
                mp, index = scamp.abjoin(data, data_b, subsequence_len, threads, gpus)
        case _: #default naive
            if print_flag: print("--> Invalid method. Using naive approach [default]")
            if ( data_b is None or self_join ): 
                data_b = data
            n_a     = len(data)
            n_b     = len(data_b)
            m       = subsequence_len
            rows    = n_b-m+1
            columns = n_a-m+1

            if print_flag:
                print("TA ~ ", n_a)
                print("TB ~ ", n_b)
                print("m =", m)
                print("Size: ", "(", rows, ",", columns, ")")
        
            DP_AB : DistanceProfile = None
            mp = np.zeros(rows)
            for i in range(rows):
                DP_AB = DistanceProfile(data = data, data_b = data_b, data_b_i = i, self_join = self_join, subsequence_len = subsequence_len)
                DP_AB.compute(print_flag = print_flag, plot_flag = plot_flag, d = d)
                mp[i] = np.nanmin(DP_AB.distances)
            
    if time_flag: 
        timer.end()
        duration = timer.duration() 
    if print_flag: 
        if time_flag: 
            print(f"matrix profile {duration} seconds -->")
        else: 
            print("matrix profile -->")
    return mp, index, index_left, index_right, duration

# %% ../nbs/mplots.ipynb 69
def compute(
    self            : MatrixProfile,
    method          : str                           = 'naive', 
    d               : Callable                      = z_normalized_euclidean_distance,
    threads         : int                           = 4, # For scamp abjoin
    gpus            : List[ int ]                   = [], # For scamp abjoin
    print_flag      : bool                          = False, 
    plot_flag       : bool                          = False,
    debug           : bool                          = True, 
    time_flag       : bool                          = True,
    provide_len     : bool                          = True,
    nlens           : Optional [ int ]              = 1
) -> Tuple [ List [ float ], List [ float ], List [ float], List[ float], Optional [ ut.Time ]]:
    self.method = method

    self.distances, self.index, self.index_left, self.index_right, self.computation_time = matrix_profile ( 
        data            = self.data, 
        subsequence_len = self.subsequence_len, 
        data_b          = self.data_b, 
        self_join       = self.self_join, 
        method          = method, 
        d               = d, 
        threads         = threads, 
        gpus            = gpus, 
        print_flag      = print_flag, 
        debug           = debug, 
        plot_flag       = plot_flag,
        time_flag       = time_flag, 
        provide_len     = provide_len,
        nlens           = nlens
    )
    return self.distances
MatrixProfile.compute = compute

# %% ../nbs/mplots.ipynb 79
@dataclass
class MatrixProfiles:
    matrix_profiles : List[ MatrixProfile ] = field( default_factory=list )
    data            : List[float]           = field( default_factory=list )
    data_b          : List[float]           = None
    
    subsequence_len: int = 0

    def append (self : 'MatrixProfiles', mp: MatrixProfile):
        self.matrix_profiles.append(deepcopy(mp))
        self.subsequence_len = mp.subsequence_len

    def compute(
        self, 
        method      : str       = 'scamp',  
        d           : Callable  = z_normalized_euclidean_distance,
        threads     : int       = 4,
        gpus        : List[int] = field( default_factory=list ),
        print_flag  : bool      = False, 
        debug       : bool      = False, 
        time_flag   : bool      = True
    ):
        """ 
        Computes the Matrix Profile for data & data_b arrays using subsequence_len length.
        Appends the resulting MP to the matrix_profiles list.
        """
        mp = MatrixProfile(
            data = self.data,
            subsequence_len=self.subsequence_len,
            data_b = self.data_b
        )
        mp.compute(
            method          = method, 
            d               = d,
            threads         = threads,
            gpus            = gpus,
            print_flag      = print_flag, 
            debug           = debug,
            time_flag       = time_flag
        )
        
        mp.method = method
        self.matrix_profiles.append(mp)
        
        if print_flag: 
            print("MPs | compute -> Subsequence len outside: ", self.subsequence_len)
            print("MPs | compute -> Subsequence len inside: ", mp.subsequence_len)
            print("MPs | compute -> method outside: ", self.matrix_profiles[-1].method)
            print("MPs | compute -> method inside: ", mp.method)
        return mp
    
    def plot(
            self        : 'MatrixProfiles', 
            ids         : Optional [ List [ int ] ] = None,
            print_flag  : bool                      = False
    ):
        if ids is None: 
            if print_flag:
                print("MPs | plot -> No ids provided | Total computed profiles:", len(self.matrix_profiles))        
            ids = range(len(self.matrix_profiles))
        num_plots = len(ids)+1
        fig = plt.figure(figsize=(10, 6))
        gs = GridSpec(num_plots, 1, height_ratios=[1] + [4] * (num_plots -1))
        # Serie temporal
        ax1 = fig.add_subplot(gs[0])
        ax1.plot(self.data, label="Data")
        ax1.set_title("Time Serie")
        ax1.legend()
        # MPlots
        for i in ids:
            ax2 = fig.add_subplot(gs[i+1], sharex=ax1)
            mp_values = self.matrix_profiles[i].distances.astype(float)
            ax2.imshow(mp_values.reshape(-1, 1).T, aspect='auto', origin='lower', cmap='hot', extent=(0, len(self.data), 0, self.subsequence_len))
            ax2.set_title(f"MPlot - {i} - {self.matrix_profiles[i].method}")
        plt.tight_layout()
        plt.show()

    def get_ordered_idx(self, id, pos):
        mp_sorted = np.argsort( self.matrix_profiles[id].distances )
        return mp_sorted[pos]
        
    def get_motif_idx(self, id): 
        motif_idx = self.get_ordered_idx(id, 0)
        self.matrix_profiles[id].motif_idx = motif_idx
        self.matrix_profiles[id].motif_nearest_neighbor_idx = self.matrix_profiles[id].index[motif_idx]
        
        if ( self.matrix_profiles[id].method == 'stump' ):
            self.matrix_profiles[id].motif_nearest_neighbor_idx_left = self.matrix_profiles[id].index_left[motif_idx]
            self.matrix_profiles[id].motif_nearest_neighbor_idx_right = self.matrix_profiles[id].index_right[motif_idx]
        return self.matrix_profiles[id].motif_idx, self.matrix_profiles[id].motif_nearest_neighbor_idx, self.matrix_profiles[id].motif_nearest_neighbor_idx_left, self.matrix_profiles[id].motif_nearest_neighbor_idx_right
    
    def get_anomaly_idx(self, id): 
        discord_idx = self.get_ordered_idx(id, -1)
        self.matrix_profiles[id].discord_idx = discord_idx
        self.matrix_profiles[id].discord_nearest_neighbor_idx = self.matrix_profiles[id].index[discord_idx]
        
        if ( self.matrix_profiles[id].method == 'stump' ):
            self.matrix_profiles[id].discord_nearest_neighbor_idx_left = self.matrix_profiles[id].index_left[discord_idx]
            self.matrix_profiles[id].discord_nearest_neighbor_idx_right = self.matrix_profiles[id].index_right[discord_idx]
            
        return self.matrix_profiles[id].discord_idx, self.matrix_profiles[id].discord_nearest_neighbor_idx, self.matrix_profiles[id].discord_nearest_neighbor_idx_left, self.matrix_profiles[id].discord_nearest_neighbor_idx_right
    
    
    def plot_motif(
        self, 
        id                  : int,
        idx                 : int,
        nearest_neighbor_idx: int,
        ts_name             : str = "Time Series",
        title_fontsize      : str = '30', 
        other_fontsize      : str = '20',
        fig_size            : Tuple [int, int] = (12,10) 
    ): 
        fig, axs = plt.subplots(2, sharex=True, gridspec_kw={'hspace': 0.4}, figsize = fig_size)
        plt.suptitle('Motif (Pattern) Discovery | ' + self.matrix_profiles[id].method , fontsize=title_fontsize)

        axs[0].plot(self.data.values)
        axs[0].set_ylabel(ts_name, fontsize=other_fontsize)
        rect = Rectangle((idx, 0), self.subsequence_len, 40, facecolor='lightgrey')
        axs[0].add_patch(rect)
        rect = Rectangle((nearest_neighbor_idx, 0), self.subsequence_len, 40, facecolor='lightgrey')
        axs[0].add_patch(rect)
        axs[1].set_xlabel('Index', fontsize =other_fontsize)
        axs[1].set_ylabel('Matrix Profile', fontsize=other_fontsize)
        axs[1].axvline(x=idx, linestyle="dashed", color = "black")
        axs[1].axvline(x=nearest_neighbor_idx, linestyle="dashed", color="red")
        axs[1].plot(self.matrix_profiles[id].distances)
        plt.show()


# %% ../nbs/mplots.ipynb 96
@dataclass
class MatrixProfilePlot:
    """ Time series similarity matrix plot """
    # -- Distances
    DM_AB : DistanceMatrix  = None
    MP_AB : MatrixProfile   = None
    # -- Compared Time Series
    data : List [ float ]     = None
    data_b : List [ float ]     = None
    subsequence_len : int   = 0
    
    # -- Algorithms
    self_join : bool        = True
    dm_method : str         = ''
    mp_method : str         = ''

    
    def compute(
        self,
        dm_method           : str       = 'naive',
        mp_method           : str       = 'naive',
        print_flag          : bool      = False,
        d                   : Callable  = z_normalized_euclidean_distance,
        debug               : bool      = False, 
        time_flag           : bool      = True, 
        allow_experimental  : bool      = True,
        ensure_symetric     : bool      = True
    ) -> Tuple [ List [ List [ float ] ], Optional [ float ] ]:
        t = None
        if time_flag:
            t = ut.Time ( function = ut.funcname() )
            t.start()
        self.dm_method = dm_method
        self.mp_method = mp_method
        self.DM_AB = DistanceMatrix(
            data            = self.data, 
            data_b          = self.data_b,
            subsequence_len = self.subsequence_len,
            self_join       = self.self_join
        )
        self.MP_AB = MatrixProfile(
            data            = self.data, 
            data_b          = self.data_b,
            subsequence_len = self.subsequence_len,
            self_join       = self.self_join
        )

        self.MP_AB.compute(
            method = mp_method,
            d = d,
            time_flag = time_flag,
            print_flag = print_flag
        )
        self.DM_AB.compute(
            method = dm_method,
            print_flag = print_flag,
            time_flag = time_flag, 
            allow_experimental = allow_experimental,
            ensure_symetric = ensure_symetric
        )
            
            
    def plot(self, ts_name="", method='Brute Force', figsize=(5, 5), show_flag=True):
        fig = plt.figure(figsize=figsize)
        gs = GridSpec(2, 1, height_ratios=[1, 4])

        # Matrix Profile
        ax1 = fig.add_subplot(gs[0])
        ax1.plot(self.MP_AB.distances, label="Time Serie")
        ax1.set_title(ts_name + " | " + method)
        ax1.legend()

        # MPlot (Distance Profile)
        ax2 = fig.add_subplot(gs[1])

        # Create the heatmap for the distance matrix
        heatmap = ax2.imshow(self.DM_AB.distances, aspect='auto', origin='lower', cmap='hot', extent=(0, len(self.DM_AB.distances), 0, len(self.DM_AB.distances[0])))

        ax2.set_title("MPlot")
        ax2.set_xlabel('TB Index')
        ax2.set_ylabel('TA Index')
        plt.colorbar(heatmap, ax=ax2, orientation='vertical', label='Distance')

        
        # Set the tick marks to be at the center of the squares
        ax2.set_xticks(np.arange(0.5, len(self.DM_AB.distances[0]), step=1))
        ax2.set_yticks(np.arange(0.5, len(self.DM_AB.distances), step=1))
        
        # Set the tick labels to be the indices starting at 0
        ax2.set_xticklabels(np.arange(0, len(self.DM_AB.distances[0])))
        ax2.set_yticklabels(np.arange(0, len(self.DM_AB.distances)))

        # Rotate tick labels for readability
        plt.setp(ax2.get_xticklabels(), rotation=45, ha="right", rotation_mode="anchor")

        plt.tight_layout()
        if show_flag:
            plt.show()
        return plt

    
    def plot_interactive(
        self, 
        ta_name="TA", 
        tb_name="TB",
        method='Brute Force', 
        figsize=(5, 5),
        print_flag = False
    ):
        fig = plt.figure(figsize=figsize)
        gs = GridSpec(4, 1, height_ratios=[1, 1, 1, 6])
      
         # Time Series Plot
        ax0 = fig.add_subplot(gs[0])
        ax0.plot(self.TA.data, label=ta_name+" Data")
        ax0.set_title(f"{ta_name} Data")
        ax0.legend()
        
        ax1 = fig.add_subplot(gs[1])
        ax1.plot(self.TB.data, label=tb_name+" Data")
        ax1.set_title(f"{tb_name} Data")
        ax1.legend()
      
        # Matrix Profile
        ax2 = fig.add_subplot(gs[2])
        ax2.plot(self.MP_AB.distances, label="Matrix Profile")
        ax2.set_title("Matrix Profile | " + method)
        ax2.legend()
        # MPlot
        ax3 = fig.add_subplot(gs[3])
        
        heatmap = ax3.imshow(
            self.DM_AB.distances, 
            aspect='auto', origin='lower', cmap='hot', 
            extent=(0, len(self.DM_AB.distances), 
                    0, len(self.DM_AB.distances[0]))
        )
        
        cbar = fig.colorbar(heatmap, ax=ax3, orientation='vertical')
        cbar.set_label('Distance')
        
        # Set the tick marks to be at the center of the squares
        ax3.set_xticks(np.arange(0.5, len(self.DM_AB.distances[0]), step=1))
        ax3.set_yticks(np.arange(0.5, len(self.DM_AB.distances), step=1))
        ax2.set_xticks(np.arange(0, len(self.DM_AB.distances[0]), step=1))
        
        
        # Set the tick labels to be the indices starting at 0
        ax3.set_xticklabels(np.arange(0, len(self.DM_AB.distances[0])))
        ax3.set_yticklabels(np.arange(0, len(self.DM_AB.distances)))

        ax3.set_title("MPlot")
        ax3.set_xlabel('TB')
        ax3.set_ylabel('TA')
    
        # Inicializa la referencia del marcador como None
        marker = None
        span0 = None
        span1 = None
        def on_hover(event):
            nonlocal marker, span0, span1
            nonlocal print_flag
            if event.inaxes == ax2:
                ta_index = int(event.xdata)
                mp_row = self.DM_AB.distances[ta_index]
                ta_distance = self.MP_AB.distances[ta_index]
                print("ta_distance", ta_distance)
                print("mp_row", mp_row)
                tb_index = np.where(
                    mp_row == ta_distance
                )[0]
                if len(tb_index) > 0:
                    tb_index = tb_index[0]
                    if print_flag: print("Ta_index", ta_index, "tb_index", tb_index)
                
                    #if print_flag: 
                    if print_flag: print("Ta_index", ta_index, "tb_index", tb_index)
                    if 0 <= ta_index < len(self.MP_AB.distances):
                        if marker is not None: marker.remove()
                        if span0 is not None: span0.remove()
                        if span1 is not None: span1.remove()
                        marker = ax3.scatter(
                            tb_index + 0.5, ta_index + 0.5,
                            color='blue', s=100, zorder=2
                        )
                    
                        span0 = ax0.axvspan(ta_index, ta_index + self.subsequence_len, color='green', alpha=0.1)
                        span1 = ax1.axvspan(tb_index, tb_index + self.subsequence_len,color = 'green', alpha=0.1)

                        fig.canvas.draw()

        
        fig.canvas.mpl_connect('motion_notify_event', on_hover)
        plt.tight_layout()
        return plt

# %% ../nbs/mplots.ipynb 101
@dataclass 
class MatrixProfilePlotCached:
    """ Specific clase for using cached interactive plots for MPlots """
    fig              : matplotlib.figure.Figure                                 = None
    ax2              : matplotlib.axes.Axes                                     = None
    ax3              : matplotlib.axes.Axes                                     = None
    ax4              : matplotlib.axes.Axes                                     = None 
    data             : List [ float ]                                           = None
    data_b           : List [ float ]                                           = None
    subsequence_len  : int                                                      = 0
    matrix_dim       : int                                                      = 0
    gs               : GridSpec                                                 = None
    cax              : matplotlib.image.AxesImage                               = None
    cache            : dict[ Tuple [ int, int, int, int], DistanceMatrix]       = field(default_factory=dict)
    filename         : str                                                      = ""
    DM_AB            : DistanceMatrix                                           = None   

    def get_matrix(
        self,
        a_id_start  : int, 
        a_id_end    : int,
        b_id_start  : int, 
        b_id_end    : int
    ) -> List [ float ]: 
        data   = self.data[a_id_start:a_id_end]
        data_b = self.data_b[b_id_start:b_id_end]
        
        cache_key = (a_id_start, a_id_end, b_id_start, b_id_end)
        matrix    = None
        
        if cache_key in self.cache:
            matrix = self.cache[cache_key]
        else:
            DM_AB = DistanceMatrix(
                data            = data,
                data_b          = data_b,
                subsequence_len = self.subsequence_len        
            )
            if len(self.data) > 1000 * self.matrix_dim and len(self.data_b) > 1000 * self.matrix_dim:
                # Currently GPU Matrix summaries can leave some spotty output if the input size is not large enough. So only allow GPU computation when we can be sure we will fill in the whole matrix
                # TODO Follow Zach (zpzim): Implement GPU Matrix summaries which will generate the same output as the CPU version.
                
                DM_AB.compute(method = 'scamp', mwidth = self.matrix_dim, mheight = self.matrix_dim)
            
            else:
                DM_AB.compute(
                    method = 'scamp', 
                    mwidth = self.matrix_dim, 
                    mheight = self.matrix_dim,
                    gpus = [], 
                    pearson = True
                )
                
            self.cache[cache_key] = matrix
            ## Cuidado con esto. Si algún día lo metemos en MVP hay que tener cuidado
            ## Porque ya al usar MatrixProfile daba problemas por detectar el 0 como patrón
            matrix[np.isnan(matrix)] = 0
        return matrix 

    def ids_int(self, ids ):
        id1, id2 = ids
        return int(id1), int(id2) 
    def on_xlims_change(self, event_ax, print_flag = True):
        a_id_start, a_id_end = self.ids_int(event_ax.get_xlim())
        b_id_end, b_id_start = self.ids_int(self.ax3.get_ylim())
        if print_flag: print(a_id_start, a_id_end, b_id_start, b_id_end)
        self.redraw_matrix(a_id_start, a_id_end, b_id_start, b_id_end)

    def on_ylims_change(self,event_ax, print_flag = True):
        st_a, ed_a = self.ids_int(self.ax2.get_xlim())
        ed_b, st_b = self.ids_int(event_ax.get_ylim())
        
        if print_flag: print(st_a, ed_a, st_b, ed_b)
        
        self.redraw_matrix(st_a, ed_a, st_b, ed_b)

    def redraw_matrix(
        self,
        a_id_start : int, 
        a_id_end : int,
        b_id_start : int,
        b_id_end : int
    ) -> None:
        matrix = self.get_matrix(a_id_start, a_id_end, b_id_start, b_id_end)
        self.cax.remove()
        self.cax = self.ax4.mathshow(
            matrix, 
            extent = [a_id_start, a_id_end, b_id_end, b_id_start], 
            interpolation = 'none'
        )
        self.ax4.set_adjustable('box')
        self.ax4.set_aspect('auto')
        self.ax4.autoscale(False)
        self.ax4.callbacks.connect('ylim_changed', self.on_ylims_change)
        self.ax4.callbacks.connect('xlim_changed', self.on_xlims_change)

    def plot_matrix_interactive(
        self, 
        data            : List [ float ], 
        data_b          : List [ float ],
        matrix_dim      : int, 
        subsequence_len : int, 
        filename        : str = "cached_matrix_plot.png",
        print_flag      : bool = True
    ) : 
        if self.data is None : 
            self.data = np.copy(data)
        if self.data_b is None : 
            if data_b is None:
                self.data_b = self.data
            else: 
                self.data_b = np.copy(data_b)
        self.subsequence_len = subsequence_len
        self.matrix_dim = matrix_dim
        if filename is not None:
            self.filename = filename

        n_x = len(self.data) - self.subsequence_len + 1
        n_y = len(self.data_b) - self.subsequence_len + 1 
        
        ratio = len(self.data) / len(self.data_b)

        matrix_dim_a = math.floor(ratio * matrix_dim)
        matrix_dim_b = self.matrix_dim

        matrix = self.get_matrix(0, len (self.data), 0, len(self.data_b))
        if print_flag : print(matrix.dtype)
        
        self.fig = plt.figure(
            constrained_layout=False, 
            facecolor='0.9', 
            figsize=(32,32)
        )
        self.gs = self.fig.add_gridspec(
            nrows=2, 
            ncols=2,  
            hspace=0, 
            wspace=0, 
            width_ratios=[1,3], 
            height_ratios=[1,3]
        )

        self.ax2 = self.fig.add_subplot(self.gs[:-1,-1])
        self.ax3 = self.fig.add_subplot(self.gs[-1,:-1])
        self.ax4 = self.fig.add_subplot(
            self.gs[-1, -1], 
            sharex=self.ax2, 
            sharey=self.ax3
        )

        cax = self.ax4.matshow(
            matrix, 
            extent=[0, n_x, n_y, 0], 
            interpolation='none'
        )
        #cax = ax4.matshow(matrix, interpolation='none')
        self.ax4.set_adjustable('box')
        self.ax4.set_aspect('auto')
        self.ax4.autoscale(False)
        axins = inset_axes(
            self.ax4, 
            width='100%', 
            height='5%', 
            loc ='lower center', 
            borderpad=-5
        )
        self.fig.colorbar(
            self.cax, 
            cax=axins, 
            orientation='horizontal'
        )
        
        self.ax4.set_axis_off()
        self.ax4.axis('off')

        self.ax2.plot([i for i in range(n_x)], data[:n_x])
        self.ax2.set_xlim(xmin=0, xmax=n_x)
        self.ax2.xaxis.set_ticks_position('top')
        self.ax2.set_axisbelow(False)
        self.ax3.plot(b[:n_y], [i for i in range(n_y)])
        self.ax3.set_ylim(ymin=0, ymax=n_y)
        self.ax3.invert_yaxis()
        self.ax3.invert_xaxis()
        ### Callbacks
        self.ax2.callbacks.connect('xlim_changed', on_xlims_change)
        self.ax3.callbacks.connect('ylim_changed', on_ylims_change)
        self.ax4.callbacks.connect('ylim_changed', on_xlims_change)
        self.ax4.callbacks.connect('xlim_changed', on_ylims_change)
        plt.show()
        if self.filename is not None:
            self.fig.savefig(filename, bbox_inches='tight')
        return self.fig
    
    def plot_matrix(self, matrix, arr, n, scale_factor, outfile):
        #Auxiliar, para testear, por eso no son las globales (entiendo)
        plt.tight_layout()
        fig = plt.figure(constrained_layout=False, facecolor='0.9', figsize=(32,32))
        gs = fig.add_gridspec(nrows=2, ncols=2,  hspace=0, wspace=0, width_ratios=[1,3], height_ratios=[1,3])

        ax2 = fig.add_subplot(gs[:-1,-1])
        ax3 = fig.add_subplot(gs[-1,:-1])
        ax4 = fig.add_subplot(gs[-1, -1])

        ax4.matshow(matrix)

        ax4.set_axis_off()
        ax4.axis('off')

        ax2.plot([i for i in range(n)], arr[:n])
        ax2.set_xlim(xmin=0, xmax=n)
        ax2.xaxis.set_ticks_position('top')
        ax2.set_axisbelow(False)
        ax3.plot(arr[:n], [i for i in range(n)])
        ax3.set_ylim(ymin=0, ymax=n)
        ax3.invert_yaxis()
        ax3.invert_xaxis()
        fig.savefig(outfile, bbox_inches='tight')
        plt.close(fig)


    
            

# %% ../nbs/mplots.ipynb 105
eamonn_drive_mplots = {
    'insects0': {
        'id': '1qq1z2mVRd7PzDqX0TDAwY7BcWVjnXUfQ',
        'name': 'InsectData-fig11'
    }
}
